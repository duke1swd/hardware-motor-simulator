/*
 * Do The Thing
 */

#include <Arduino.h>
#include <LiquidCrystal.h>
#include "io_ref.h"
#include "state.h"
#include "menu.h"
#include "log.h"
#include "dac.h"
#include "pressure.h"

// amount of noise we put on simulated pressure traces.
// Should be smaller than hysteresis value (3) in inputs.cpp
#define	NOISE	2

extern LiquidCrystal lcd;
extern unsigned long loop_time;
static unsigned long next_check_time;
static unsigned long test_start_time;
static const unsigned long check_interval = 100; // milliseconds
extern void running_state(bool);

#define	IG_DELAY		25		// igniter fires 25 ms after spark + propellants

#define	PROPELLANT_LOAD		4000		// in 4 seconds of full throttle.  Units are ms.

#define	N2O_SERVO_MIN		(44+5)		// degress.  Off.
#define	N2O_SERVO_MAX		(N2O_SERVO_MIN + 170)
#define	IPA_SERVO_MIN		(44+5)		// degress.  Off.
#define	IPA_SERVO_MAX		(IPA_SERVO_MIN + 170)

bool fr_sim_ig;		// true if we are simulating the igniter pressure sensor

/*
 * Common cleanup and state exit routine.
 * Called either by input_action_button or by running out of fuel
 */
static void do_exit() {
	input_action_button = false;
	dac_set(DAC_MAIN, NO_PRESSURE);
	log_enabled = false;
	log_commit();
	output_led = LED_OFF;
	state_new(menu_state);
}

void full_run_state(bool first_time) {

	if (first_time) {
/*xxx*/Serial.print("Full Run State\n"); delay(1000);
		log_reset();
		log_enabled = true;
		lcd.clear();
		lcd.print("Full Run");
		next_check_time = 0;
		output_led = LED_ON;
		dac_set(DAC_MAIN, NO_PRESSURE);
	}

	if (loop_time >= next_check_time) {
		first_time = true;
		next_check_time = loop_time + check_interval;
	}
	
	if (input_action_button) {
		do_exit();
		return;
	}

	if (first_time) {
		fr_sim_ig = !dac_ig_press_present();
		lcd.setCursor(1, 0);
		if (fr_sim_ig) {
			lcd.print("Simulated Ignitor");
			dac_set(DAC_IG, NO_PRESSURE);
		} else
			lcd.print("Real Igniter     ");
	}

	if (input_ig_valve_ipa_level || input_ig_valve_n2o_level || input_spark_sense)
		state_new(running_state);
}

/*
 * Monitor the igniter.
 * Log when pressure becomes good.
 * Record when it became good so simulated main will wait awhile after igniter to work.
 *
 * This routine is called and does the right thing regardless of whether ig pressure is
 * from a real sensor or generated by the pressure sensor simulator.
 */
static bool ig_pressure_good;
static bool ig_pressure_has_been_good;
static unsigned long ig_pressure_start;
static unsigned long ig_good_time;		// Time when we think the igniter should fire.

static void monitor_ig() {
	bool b;

	b = (input_ig_press >= IG_PRESS_GOOD);
	if (b && !ig_pressure_has_been_good) {
		log(LOG_IG_PRESSURE_GOOD_1, 0);
		ig_pressure_has_been_good = true;
	} else if (b && !ig_pressure_good)
		log(LOG_IG_PRESSURE_GOOD, 0);

	if (b && !ig_pressure_good)
		ig_pressure_start = loop_time;	// set on rising edge
	ig_pressure_good = b;
}

/*
 * Simulate the ingiter.  We do this every millisecond.
 */
static unsigned long sim_ig_next_update;
static const unsigned long sim_ig_interval = 1;
static bool sim_ig_changing;
static int sim_ig_output;
static int sim_ig_increment;
static int sim_ig_output_target;
static int sim_noise;

static void sim_ig() {
	sim_noise++;
	if (sim_noise > NOISE)
		sim_noise = -NOISE;

	// avoid running too often
	if (loop_time < sim_ig_next_update)
		return;
	sim_ig_next_update = loop_time + sim_ig_interval;

	// If we are changing the output signal, do so gradually.
	if (sim_ig_changing) {
		sim_ig_output += sim_ig_increment;
		if (sim_ig_increment > 0) {
			if (sim_ig_output >= sim_ig_output_target) {
				sim_ig_output = sim_ig_output_target;
				sim_ig_changing = false;
			}
		} else {
			if (sim_ig_output <= sim_ig_output_target) {
				sim_ig_output = sim_ig_output_target;
				sim_ig_changing = false;
			}
		}
	}
	dac_set(DAC_IG, sim_ig_output + sim_noise);

	// If any of the valves are off, kill the ig pressure
	if ((!input_ig_valve_ipa_level || !input_ig_valve_n2o_level) &&
			( sim_ig_output > NO_PRESSURE ||
			  sim_ig_output_target > NO_PRESSURE)) {
		sim_ig_changing = true;
		sim_ig_output_target = NO_PRESSURE;
		sim_ig_increment = -500;	// I just made this up.
	}

	// If conditions are right, and have been for awhile, ig pressure up.
	if (input_ig_valve_ipa_level && input_ig_valve_n2o_level && input_spark_sense) {
		if (ig_good_time == 0)
			ig_good_time = loop_time + IG_DELAY;
		else if (loop_time >= ig_good_time) {
			ig_good_time = 0;
			sim_ig_changing = true;
			sim_ig_increment = 300;	// come up to pressure in 5 ms ?
			sim_ig_output_target = IG_PRESSURE_TARGET;
		}
	}

	// If conditions are not right for ignition, don't let it start
	if (!input_ig_valve_ipa_level || !input_ig_valve_n2o_level || !input_spark_sense)
		ig_good_time = 0;
}

/*
 * Main chamber fires when propellants are present and igniter has been at pressure
 * for some minimum time.
 *
 * Each servo is converted into a percentage.  The smaller percentage is used to scale
 * the chamber pressure.
 *
 * Chamber running time is the integral of chamber pressure percentage.  System is loaded
 * with a specified amount (in seconds) of propellants.
 *
 * When propellants run out, we exit to log review state.
 */
static unsigned int sim_main_next_update;
static const unsigned long sim_main_interval = 1;
static const unsigned int servo_slew_inv_rate = 2;	// 2 milliseconds to slew 1 degree
static int ipa_servo_pos;
static int n2o_servo_pos;
static int ipa_pct;		// percent of full flow rate that the valve is open
static int n2o_pct;		// percent of full flow rate that the valve is open
static int ipa_level;		// amount of ipa we have left
static int n2o_level;
static int ipa_fractional_consumed;	// sum of pct each ms.
static int n2o_fractional_consumed;

// compute the simulated servo positions.
// simulate the propellant flow rates
static void servo_slew() {
	int servo_target;

	if (loop_time % servo_slew_inv_rate > 0)
		return;

	servo_target = servo_read_ipa();
	if (servo_target > 0 && servo_target != ipa_servo_pos) {
		if (servo_target > ipa_servo_pos)
			ipa_servo_pos++;
		else
			ipa_servo_pos--;
	}

	servo_target = servo_read_n2o();
	if (servo_target > 0 && servo_target != n2o_servo_pos) {
		if (servo_target > n2o_servo_pos)
			n2o_servo_pos++;
		else
			n2o_servo_pos--;
	}
}

static void sim_main() {
	int chamber_pct;
	extern void log_review_state(bool);

	// avoid running too often
	if (loop_time < sim_main_next_update)
		return;
	sim_main_next_update = loop_time + sim_main_interval;

	servo_slew();

	if (ipa_servo_pos <= IPA_SERVO_MIN)
		ipa_pct = 0;
	else if (ipa_servo_pos >= IPA_SERVO_MAX)
		ipa_pct = 100;
	else {
		ipa_pct = 100 * (ipa_servo_pos - IPA_SERVO_MIN) /
			(IPA_SERVO_MAX - IPA_SERVO_MIN);
	}

	ipa_fractional_consumed += ipa_pct;
	ipa_level -= ipa_fractional_consumed / 100;
	ipa_fractional_consumed %= 100;

	if (n2o_servo_pos <= N2O_SERVO_MIN)
		n2o_pct = 0;
	else if (n2o_servo_pos >= N2O_SERVO_MAX)
		n2o_pct = 100;
	else {
		n2o_pct = 100 * (n2o_servo_pos - N2O_SERVO_MIN) /
			(IPA_SERVO_MAX - IPA_SERVO_MIN);
	}

	n2o_fractional_consumed += n2o_pct;
	n2o_level -= n2o_fractional_consumed / 100;
	n2o_fractional_consumed %= 100;

	if (n2o_level < 0 || ipa_level < 0) {
		do_exit();
		state_new(log_review_state);
		return;
	}

	chamber_pct = min(n2o_pct, ipa_pct);
	dac_set(DAC_MAIN, chamber_pct * MAX_MAIN_PRESSURE / 100);
}

/*
 * This state handles running the test.
 */
void running_state(bool first_time) {
	if (input_action_button) {
		do_exit();
		return;
	}

	if (first_time) {
		output_led = LED_BLINKING;
		test_start_time = loop_time;
		ig_pressure_good = false;
		ig_pressure_has_been_good = false;
		sim_ig_changing = false;
		sim_ig_output = NO_PRESSURE;	// no pressure, but sensor present.
		sim_ig_next_update = 0;

		n2o_level = PROPELLANT_LOAD;
		ipa_level = PROPELLANT_LOAD;
		ipa_pct = 0;
		ipa_fractional_consumed = 0;
		n2o_pct = 0;
		n2o_fractional_consumed = 0;
		sim_main_next_update = 0;
	}

	if (fr_sim_ig)
		sim_ig();

	monitor_ig();

	sim_main();
}
